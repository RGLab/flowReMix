#' Auxiliary for Controlling flowReMix Fitting.
#'
#' @description Auxiliary function for \code{\link{flowReMix}} fitting. Can be
#'   used to generate an appropriate object for modifying the fitting process of
#'   the stochastic EM algorithm used by \code{flowReMix}.
#'
#' @param updateLag number of iterations before the algorithm is assumed to
#'   converge, at which time the parameter estimates will be aggregated.
#'
#' @param randomAssignProb an optional parameter for adding noise to the cluster
#'   assignments generated by the Gibbs sampler. Should only be changed if ising
#'   model estimates are unstable.
#'
#' @param nsamp number of Gibbs/componentwise MH cycles to perform for each
#'   subject. Must be larger than keepEach.
#'
#' @param lastSample how many samples to keep from the final iteration.
#'
#' @param initMHcoef the initial value for the shrinkage/inflation to perform on
#'   the estimated covariance in the componentwise MH sampler. The initial value
#'   does not matter much as this parameter self-tunes as the algorithm runs and
#'   usually converges to a good value within a few iterations.
#'
#' @param nPosteriors number of posterior samples to take per subject. If left
#'   as \code{NULL} then a value will be determined within flowReMix according
#'   to a preset formula.
#'
#' @param minDispersion the minimum overdispersion allowed. The larger the value of the variable the less overdispersion is allowed.
#'
#'
#' @param isingInit initialize the Ising model with this value.
#'
#' @param maxDispersion the maximum overdispersion level allowed. The lower the
#'   value of the variable the more overdispersion is allowed. Must be larger
#'   than 0.
#'
#' @param keepEach one out of how many Gibbs/MH samples to keep. This is used to
#'   reduce the dependence between posterior samples.
#'
#' @param centerCovariance whether to center random effect estimates before
#'   computing the covariance estimate or not.
#'
#' @param intSampSize number of importance samples to take when performing
#'   univariate numerical integration in the Gibbs sampler.
#'
#' @param initMethod the method used to initialize the regression coefficients.
#'   Options are either "sparse" for \code{\link[glmnet]{cv.glmnet}} or "binom"
#'   for \code{\link[stats]{glm}}. If left as \code{NULL} then it will be determined
#'   according to the regression_method specified for the \code{flowReMix} call.
#'
#' @param ncores The number of cpu cores to use to fit the model in parallel.
#'
#' @param preAssignCoefs coefficients to multiply the posterior probabilities. 0 is a hard assignment and observations that are
#' designated non-responders based on pu > ps will have posterior probabilities of 0. > 0 is a soft assignment, and a prior will be
#' placed on the prior probability of non-response in the Ising model.
#'
#' @param markovChainEM \code{logical} use the mcEM algorithm to fit the model. Default TRUE.
#'
#' @param zeroPosteriorProbs boolean. \code{TRUE} will zero out posterior response
#' probabilities where pu>ps, equivalent to a one-sided test. The full set of responses
#' will still be used to estimate the Ising model. Default \code{FALSE}. Can be used together
#' with the prior argument on the Ising model.
#'
#' @param seed \code{numeric} a random seed for reproducible initialization. Default 100.
#'
#' @param prior \code{numeric} value, a prior for response and non-response in the Ising model
#' used constrain non-responders (e.g. when pu>ps).
#'
#' @param isingWprior \code{logical} fit the Ising model with a prior on the baseline response using the parameter in \code{prior}. Default TRUE.
#'
#' @param clusterType \code{character} type of cluster. AUTO, FORK, SOCK. Default AUTO. Can be changed if the default doesn't work.
#'
#' @param sampleNew \code{logical} should the stability selection draw new samples. Default \code{FALSE}.
#'
#' @return An object of type \code{flowReMix_control}.
#'
#' @export
flowReMix_control <- function(updateLag = 10, randomAssignProb = 1e-8, nsamp = 50,
                              lastSample = 100, initMHcoef = 2.5, nPosteriors = 3,
                              maxDispersion = 10^3, minDispersion = 10^7, isingInit = -4.59512,
                              keepEach = 5, centerCovariance = FALSE, intSampSize = 100,
                              initMethod = "robust", ncores = NULL, preAssignCoefs = 1,
                              markovChainEM = TRUE, seed=100, prior = 0,
                              isingWprior = TRUE, zeroPosteriorProbs = TRUE,
                              clusterType = c("AUTO","FORK","SOCK"),
                              isingStabilityReps = 200, randStabilityReps = 0,
                              learningRate = 0.6, keepWeightPercent = 0.9, sampleNew = FALSE,
                              subsetDiscardThreshold = 0) {

  object <- list(updateLag = updateLag,
                 randomAssignProb = randomAssignProb,
                 nsamp = nsamp,
                 lastSample = lastSample,
                 initMHcoef = initMHcoef,
                 nPosteriors = nPosteriors,
                 maxDispersion = maxDispersion,
                 minDispersion = minDispersion,
                 isingInit = isingInit,
                 keepEach = keepEach,
                 centerCovariance = centerCovariance,
                 intSampSize = intSampSize,
                 initMethod = initMethod,
                 ncores = ncores,
                 preAssignCoefs = preAssignCoefs,
                 markovChainEM = markovChainEM,
                 seed=seed,
                 prior = abs(prior),
                 isingWprior = isingWprior,
                 zeroPosteriorProbs = zeroPosteriorProbs,
                 clusterType=c("AUTO","SOCK","FORK"),
                 isingStabilityReps = isingStabilityReps,
                 randStabilityReps = randStabilityReps,
                 learningRate = learningRate,
                 keepWeightPercent = keepWeightPercent,
                 sampleNew = sampleNew,
                 subsetDiscardThreshold = subsetDiscardThreshold)
  class(object) <- "flowReMix_control"
  return(object)
}


# @importFrom GGally ggnet2
# @importFrom stats na.pass
# @importFrom stats model.matrix
# @importFrom stats model.frame
# @importFrom network network
# computeGraphAUC <- function(object, outcome = NULL, reps = 100,
#                             samples = NULL,
#                             props = NULL,
#                             AND = TRUE,
#                             screen = TRUE,
#                             threhsold = 0.5) {
#   # Computing AUCs --------------------------------
#   if(!is.null(outcome)) {
#     if(!is.null(samples)) {
#       posteriors <- data.frame(t(sapply(samples, colMeans)))
#       posteriors <- cbind(object$posteriors[, 1], posteriors)
#       colnames(posteriors)[1] <- "id"
#     } else {
#       posteriors <- object$posteriors
#     }
#
#     colnames(outcome)[1] <- "id"
#     posteriors <- merge(posteriors, outcome,
#                         all.x = TRUE, by.x = "id", by.y = "id")
#     ctrlCol <- ncol(posteriors)
#
#     aucs <- numeric(ctrlCol - 2)
#     n1 <- sum(posteriors[, ctrlCol] == 1)
#     n0 <- sum(posteriors[, ctrlCol] == 0)
#     outcome <- posteriors[, ctrlCol]
#     for(i in 2:(ctrlCol - 1)) {
#       post <- posteriors[, i]
#       rocfit <- roc(outcome ~ post)
#       subset <- names(posteriors)[i]
#       auc <- rocfit$auc
#       aucs[i - 1] <- auc
#     }
#
#     pvals <- pwilcox(aucs * n0 * n1, n0, n1, lower.tail = FALSE)
#     pvals <- 2 * pmin(pvals,  1 - pvals)
#     qvals <- p.adjust(pvals, method = "BY")
#     subsets <- names(posteriors)[-c(1, ctrlCol)]
#     result <- data.frame(subsets, aucs, pvals, qvals)
#   } else {
#     posteriors <- object$posteriors
#     levelProbs <- colMeans(posteriors[, 2:ncol(posteriors)])
#     result <- NULL
#   }
#
#
#   # Estimating graph -------------------
#   if(is.null(samples)) {
#     assignments <- object$assignmentList
#   } else {
#     assignments <- samples
#   }
#
#   if(is.null(props)) {
#     modelList <- list()
#     nsubsets <- ncol(assignments[[1]])
#     countCovar <- matrix(0, nrow = nsubsets, ncol = nsubsets)
#     for(i in 1:reps) {
#       mat <- t(sapply(assignments, function(x) x[sample(1:nrow(x), 1), ]))
#       colnames(mat) <- names(object$coefficients)
#       keep <- apply(mat, 2, function(x) any(x != x[1]))
#       mat <- mat[, keep]
#       model <- IsingFit(mat, AND = AND, plot = FALSE)
#       modelList[[i]] <- model
#       #plot(model)
#       countCovar[keep, keep] <- countCovar[keep, keep] + (model$weiadj != 0) * sign(model$weiadj)
#       print(c(rep = i))
#     }
#
#     props <- countCovar / reps
#     props[abs(props) <= threshold] <- 0
#   }
#
#   # Plotting graph ---------------------
#   network <- props
#   if(screen) {
#     keep <- apply(network, 1, function(x,threshold=threshold) any(abs(x) >= threshold))
#     network <- network[keep, keep]
#   } else {
#     keep <- rep(TRUE, length(props))
#   }
#   net <- network(props)
#   subsets <- names(object$coefficients)
#   nodes <- ggnet2(network, label = subsets[keep])$data
#   edges <- matrix(nrow = sum(network != 0)/2, ncol = 5)
#   p <- nrow(network)
#   row <- 1
#   for(j in 2:p) {
#     for(i in 1:(j-1)) {
#       if(network[i, j] != 0) {
#         edges[row, ] <- unlist(c(nodes[i, 6:7], nodes[j, 6:7], network[i, j]))
#         row <- row + 1
#       }
#     }
#   }
#
#   edges <- data.frame(edges)
#   names(edges) <- c("xstart", "ystart", "xend", "yend", "width")
#   nodes$auc <- aucs[keep]
#   nodes$qvals <- result$qvals[keep]
#   nodes$sig <- nodes$qvals < 0.1
#
#   names(edges)[5] <- "Dependence"
#   lims <- max(abs(props))
#   plot <- ggplot() +
#     scale_colour_gradient2(limits=c(-lims, lims), low="dark red", high = "dark green") +
#     geom_segment(data = edges, aes(x = xstart, y = ystart,
#                                    xend = xend, yend = yend,
#                                    col = Dependence,
#                                    alpha = abs(Dependence)),
#                  size = 1) +
#     scale_fill_gradientn(colours = rainbow(4))
#   if(is.null(outcome)) {
#     plot <- plot + geom_point(data = nodes, aes(x = x, y = y, fill = auc), shape = 21,
#                               size = 8, col = "grey")
#   } else {
#     plot <- plot + geom_point(data = nodes, aes(x = x, y = y, fill = levelProbs), shape = 21,
#                               size = 8, col = "grey")
#   }
#   plot <- plot + scale_shape(solid = FALSE) +
#     geom_text(data = nodes, aes(x = x, y = y, label = nodes$label), size = 1.8) +
#     theme(axis.line=element_blank(),axis.text.x=element_blank(),
#           axis.text.y=element_blank(),axis.ticks=element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
#           panel.grid.minor=element_blank(),plot.background=element_blank())
#
#   return(list(graphplot = plot, props = props, auctable = result))
# }
#
#
#
#
#
