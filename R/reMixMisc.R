#' Auxiliary for Controlling flowReMix Fitting.
#'
#' @description Auxiliary function for \code{\link{flowReMix}} fitting. Can be
#'   used to generate an appropriate object for modifying the fitting process of
#'   the stochastic EM algorithm used by \code{flowReMix}.
#'
#' @param updateLag number of iterations before the algorithm is assumed to
#'   converge, at which time the parameter estimates will be aggregated.
#'
#' @param randomAssignProb an optional parameter for adding noise to the cluster
#'   assignments generated by the Gibbs sampler. Should only be changed if ising
#'   model estimates are unstable.
#'
#' @param nsamp number of Gibbs/componentwise MH cycles to perform for each
#'   subject. Must be larger than keepEach.
#'
#' @param initMHcoef the initial value for the shrinkage/inflation to perform on
#'   the estimated covariance in the componentwise MH sampler. The initial value
#'   does not matter much as this parameter self-tunes as the algorithm runs and
#'   usually converges to a good value within a few iterations.
#'
#' @param nPosteriors number of posterior samples to take per subject. If left
#'   as \code{NULL} then a value will be determined within flowReMix according
#'   to a preset formula.
#'
#' @param maxDispersion the maximum overdispersion level allowed. The lower the
#'   value of the variable the more overdispersion is allowed. Must be larger
#'   than 0.
#'
#' @param keepEach one out of how many Gibbs/MH samples to keep. This is used to
#'   reduce the dependence between posterior samples.
#'
#' @param centerCovariance whether to center random effect estimates before
#'   computing the covariance estimate or not.
#'
#' @param intSampSize number of importance samples to take when performing
#'   univariate numerical integration in the Gibbs sampler.
#'
#' @param initMethod the method used to initialize the regression coefficients.
#'   Options are either "sparse" for \code{\link[glmnet]{cv.glmnet}} or "binom"
#'   for \code{\link[stats]{glm}}. If left as \code{NULL} then it will be determined
#'   according to the regression_method specified for the \code{flowReMix} call.
#'
#' @return An object of type \code{flowReMix_control}.
#'
#' @export
flowReMix_control <- function(updateLag = 5, randomAssignProb = 0.0, nsamp = 20,
                              lastSample = NULL, initMHcoef = 0.4, nPosteriors = NULL,
                              maxDispersion = 10^3, minDispersion = 10^8, isingInit = -4,
                              keepEach = 5, centerCovariance = TRUE, intSampSize = 100,
                              initMethod = NULL, ncores = NULL, preAssignCoefs = 0,
                              markovChainEM = TRUE) {

  object <- list(updateLag = updateLag,
                 randomAssignProb = randomAssignProb,
                 nsamp = nsamp,
                 lastSample = lastSample,
                 initMHcoef = initMHcoef,
                 nPosteriors = nPosteriors,
                 maxDispersion = maxDispersion,
                 minDispersion = minDispersion,
                 isingInit = isingInit,
                 keepEach = keepEach,
                 centerCovariance = centerCovariance,
                 intSampSize = intSampSize,
                 initMethod = initMethod,
                 ncores = ncores,
                 preAssignCoefs = preAssignCoefs,
                 markovChainEM = markovChainEM)
  class(object) <- "flowReMix_control"
  return(object)
}


#' @export
computeGraphAUC <- function(object, outcome = NULL, reps = 100,
                            samples = NULL,
                            props = NULL,
                            AND = TRUE,
                            screen = TRUE,
                            threhsold = 0.5) {
  # Computing AUCs --------------------------------
  if(!is.null(outcome)) {
    if(!is.null(samples)) {
      posteriors <- data.frame(t(sapply(samples, colMeans)))
      posteriors <- cbind(fit$posteriors[, 1], posteriors)
      colnames(posteriors)[1] <- "id"
    } else {
      posteriors <- object$posteriors
    }

    colnames(outcome)[1] <- "id"
    posteriors <- merge(posteriors, outcome,
                        all.x = TRUE, by.x = "id", by.y = "id")
    ctrlCol <- ncol(posteriors)

    aucs <- numeric(ctrlCol - 2)
    n1 <- sum(posteriors[, ctrlCol] == 1)
    n0 <- sum(posteriors[, ctrlCol] == 0)
    outcome <- posteriors[, ctrlCol]
    for(i in 2:(ctrlCol - 1)) {
      post <- posteriors[, i]
      rocfit <- roc(outcome ~ post)
      subset <- names(posteriors)[i]
      auc <- rocfit$auc
      aucs[i - 1] <- auc
    }

    pvals <- pwilcox(aucs * n0 * n1, n0, n1, lower.tail = FALSE)
    pvals <- 2 * pmin(pvals,  1 - pvals)
    qvals <- p.adjust(pvals, method = "BY")
    subsets <- names(posteriors)[-c(1, ctrlCol)]
    result <- data.frame(subsets, aucs, pvals, qvals)
  } else {
    posteriors <- fit$posteriors
    levelProbs <- colMeans(posteriors[, 2:ncol(posteriors)])
    result <- NULL
  }


  # Estimating graph -------------------
  if(is.null(samples)) {
    assignments <- object$assignmentList
  } else {
    assignments <- samples
  }

  if(is.null(props)) {
    modelList <- list()
    nsubsets <- ncol(assignments[[1]])
    countCovar <- matrix(0, nrow = nsubsets, ncol = nsubsets)
    for(i in 1:reps) {
      mat <- t(sapply(assignments, function(x) x[sample(1:nrow(x), 1), ]))
      colnames(mat) <- names(object$coefficients)
      keep <- apply(mat, 2, function(x) any(x != x[1]))
      mat <- mat[, keep]
      model <- IsingFit::IsingFit(mat, AND = AND, plot = FALSE)
      modelList[[i]] <- model
      #plot(model)
      countCovar[keep, keep] <- countCovar[keep, keep] + (model$weiadj != 0) * sign(model$weiadj)
      print(c(rep = i))
    }

    props <- countCovar / reps
    props[abs(props) <= threshold] <- 0
  }

  # Plotting graph ---------------------
  require(GGally)
  library(network)
  library(sna)
  network <- props
  if(screen) {
    keep <- apply(network, 1, function(x) any(abs(x) >= threshold))
    network <- network::network[keep, keep]
  } else {
    keep <- rep(TRUE, length(props))
  }
  net <- network::network(props)
  subsets <- names(object$coefficients)
  nodes <- GGally::ggnet2(network, label = subsets[keep])$data
  edges <- matrix(nrow = sum(network != 0)/2, ncol = 5)
  p <- nrow(network)
  row <- 1
  for(j in 2:p) {
    for(i in 1:(j-1)) {
      if(network[i, j] != 0) {
        edges[row, ] <- unlist(c(nodes[i, 6:7], nodes[j, 6:7], network[i, j]))
        row <- row + 1
      }
    }
  }

  edges <- data.frame(edges)
  names(edges) <- c("xstart", "ystart", "xend", "yend", "width")
  nodes$auc <- aucs[keep]
  nodes$qvals <- result$qvals[keep]
  nodes$sig <- nodes$qvals < 0.1

  names(edges)[5] <- "Dependence"
  lims <- max(abs(props))
  plot <- ggplot() +
    scale_colour_gradient2(limits=c(-lims, lims), low="dark red", high = "dark green") +
    geom_segment(data = edges, aes(x = xstart, y = ystart,
                                   xend = xend, yend = yend,
                                   col = Dependence,
                                   alpha = abs(Dependence)),
                 size = 1) +
    scale_fill_gradientn(colours = rainbow(4))
  if(is.null(outcome)) {
    plot <- plot + geom_point(data = nodes, aes(x = x, y = y, fill = auc), shape = 21,
                              size = 8, col = "grey")
  } else {
    plot <- plot + geom_point(data = nodes, aes(x = x, y = y, fill = levelProbs), shape = 21,
                              size = 8, col = "grey")
  }
  plot <- plot + scale_shape(solid = FALSE) +
    geom_text(data = nodes, aes(x = x, y = y, label = nodes$label), size = 1.8) +
    theme(axis.line=element_blank(),axis.text.x=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),plot.background=element_blank())

  return(list(graphplot = plot, props = props, auctable = result))
}





