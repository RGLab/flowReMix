#' Auxiliary for Controlling flowReMix Fitting.
#'
#' @description Auxiliary function for \code{\link{flowReMix}} fitting. Can be
#'   used to generate an appropriate object for modifying the fitting process of
#'   the stochastic EM algorithm used by \code{flowReMix}.
#'
#' @param updateLag number of iterations before the algorithm is assumed to
#'   converge, at which time the parameter estimates will be aggregated.
#'
#' @param randomAssignProb an optional parameter for adding noise to the cluster
#'   assignments generated by the Gibbs sampler. Should only be changed if ising
#'   model estimates are unstable.
#'
#' @param nsamp number of Gibbs/componentwise MH cycles to perform for each
#'   subject. Must be larger than keepEach.
#'
#' @param lastSample how many samples to keep from the final iteration.
#'
#' @param initMHcoef the initial value for the shrinkage/inflation to perform on
#'   the estimated covariance in the componentwise MH sampler. The initial value
#'   does not matter much as this parameter self-tunes as the algorithm runs and
#'   usually converges to a good value within a few iterations.
#'
#' @param nPosteriors number of posterior samples to take per subject. If left
#'   as \code{NULL} then a value will be determined within flowReMix according
#'   to a preset formula.
#'
#' @param minDispersion the minimum overdispersion allowed. The larger the value of the variable the less overdispersion is allowed.
#'
#'
#' @param isingInit initialize the Ising model with this value.
#'
#' @param maxDispersion the maximum overdispersion level allowed. The lower the
#'   value of the variable the more overdispersion is allowed. Must be larger
#'   than 0.
#'
#' @param keepEach one out of how many Gibbs/MH samples to keep. This is used to
#'   reduce the dependence between posterior samples.
#'
#' @param centerCovariance whether to center random effect estimates before
#'   computing the covariance estimate or not.
#'
#' @param intSampSize number of importance samples to take when performing
#'   univariate numerical integration in the Gibbs sampler.
#'
#' @param initMethod the method used to initialize the regression coefficients.
#'   Options are either "sparse" for \code{\link[glmnet]{cv.glmnet}} or "binom"
#'   for \code{\link[stats]{glm}}. If left as \code{NULL} then it will be determined
#'   according to the regression_method specified for the \code{flowReMix} call.
#'
#' @param ncores The number of cpu cores to use to fit the model in parallel.
#'
#' @param preAssignCoefs coefficients to multiply the posterior probabilities. 0 is a hard assignment and observations that are
#' designated non-responders based on pu > ps will have posterior probabilities of 0. > 0 is a soft assignment, and a prior will be
#' placed on the prior probability of non-response in the Ising model.
#'
#' @param markovChainEM \code{logical} use the mcEM algorithm to fit the model. Default TRUE.
#'
#' @param zeroPosteriorProbs boolean. \code{TRUE} will zero out posterior response
#' probabilities where pu>ps, equivalent to a one-sided test. The full set of responses
#' will still be used to estimate the Ising model. Default \code{FALSE}. Can be used together
#' with the prior argument on the Ising model.
#'
#' @param seed \code{numeric} a random seed for reproducible initialization. Default 100.
#'
#' @param prior \code{numeric} value, a prior for response and non-response in the Ising model
#' used constrain non-responders (e.g. when pu>ps).
#'
#' @param isingWprior \code{logical} fit the Ising model with a prior on the baseline response using the parameter in \code{prior}. Default TRUE.
#'
#' @param clusterType \code{character} type of cluster. AUTO, FORK, SOCK. Default AUTO. Can be changed if the default doesn't work.
#'
#' @param sampleNew \code{logical} should the stability selection draw new samples. Default \code{FALSE}.
#'
#' @return An object of type \code{flowReMix_control}.
#'
#' @export
flowReMix_control <- function(updateLag = 10, randomAssignProb = 1e-8, nsamp = 50,
                              lastSample = NULL, initMHcoef = 2.5, nPosteriors = 3,
                              maxDispersion = 10^3, minDispersion = 10^7, isingInit = -4.59512,
                              keepEach = 5, centerCovariance = FALSE, intSampSize = 100,
                              initMethod = "robust", ncores = NULL, preAssignCoefs = 1,
                              markovChainEM = TRUE, seed=100, prior = 0,
                              isingWprior = TRUE, zeroPosteriorProbs = FALSE,
                              clusterType = c("AUTO","FORK","SOCK"),
                              isingStabilityReps = 200, randStabilityReps = 0,
                              learningRate = 0.6, keepWeightPercent = 0.9, sampleNew = FALSE,
                              subsetDiscardThreshold = 0) {
  object <- list(updateLag = updateLag,
                 randomAssignProb = randomAssignProb,
                 nsamp = nsamp,
                 lastSample = lastSample,
                 initMHcoef = initMHcoef,
                 nPosteriors = nPosteriors,
                 maxDispersion = maxDispersion,
                 minDispersion = minDispersion,
                 isingInit = isingInit,
                 keepEach = keepEach,
                 centerCovariance = centerCovariance,
                 intSampSize = intSampSize,
                 initMethod = initMethod,
                 ncores = ncores,
                 preAssignCoefs = preAssignCoefs,
                 markovChainEM = markovChainEM,
                 seed=seed,
                 prior = abs(prior),
                 isingWprior = isingWprior,
                 zeroPosteriorProbs = zeroPosteriorProbs,
                 clusterType=c("AUTO","SOCK","FORK"),
                 isingStabilityReps = isingStabilityReps,
                 randStabilityReps = randStabilityReps,
                 learningRate = learningRate,
                 keepWeightPercent = keepWeightPercent,
                 sampleNew = sampleNew,
                 subsetDiscardThreshold = subsetDiscardThreshold)
  class(object) <- "flowReMix_control"
  return(object)
}


