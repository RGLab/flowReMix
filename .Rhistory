subsets <- names(fit$coefficients)
nfunctions <- sapply(subsets, function(x) length(strsplit(x, "+", fixed = TRUE)[[1]]) - 1)
weightList <- list()
weightList$poly <-  weights <- nfunctions / choose(5, nfunctions)
weightList$func <- rep(1, length(nfunctions))
resultList <- list()
for(w in 1:length(weightList)) {
weights <- weightList[[w]]
weightname <- names(weightList)[w]
resultList[[w]] <- list()
print(weightname)
for(i in 1:(length(assignments) + 3)) {
cat(i, " ")
if(i <= length(assignments)) {
samp <- assignments[[i]]
ptid <- fit$posteriors$ptid[i]
} else if(i == (length(assignments) + 1)) {
ptid <- "non-infected"
samp <- do.call("rbind", assignments[infect[, 3] == "non-infected"])
} else if(i == (length(assignments) + 2)){
ptid <- "placebo"
samp <- do.call("rbind", assignments[infect[, 3] == "placebo"])
} else {
ptid <- "infected"
samp <- do.call("rbind", assignments[infect[, 3] == "infected"])
}
#colnames(samp) <- substring(subsets, 1, 3) # for stim groups
colnames(samp) <- substring(subsets, 1, 6) # for stim + 8 or 4 groups
#colnames(samp) <- substring(subsets, 5, 6) # + 8 or 4 groups
#colnames(samp) <- substring(subsets, 5) # for cell-type groups
#colnames(samp) <- rep("all", ncol(samp)) # for just one plot
groups <- unique(colnames(samp))
subjDatList <- list()
for(j in 1:length(groups)) {
group <- groups[j]
subsamp <- samp[, colnames(samp) == group]
subw <- weights[colnames(samp) == group]
subw <- subw / sum(subw)
groupSize <- ncol(subsamp)
props <- numeric(groupSize + 1)
values <- subsamp %*% subw
uniqueValues <- c(0, sort(unique(values)), 1)
props <- sapply(uniqueValues, function(x) mean(values >= x))
subjDatList[[j]] <- data.frame(ptid = ptid, group = group,
index = weightname,
presponses = uniqueValues,
postProb = props)
}
resultList[[w]][[i]] <- do.call("rbind", subjDatList)
}
cat("\n")
}
responsedat <- do.call("rbind", do.call("rbind", resultList))
forplot <- merge(responsedat, infect, by.x = "ptid", by.y = "ptid",
all.x = TRUE)
summarized <- subset(forplot, ptid %in% c("infected", "non-infected", "placebo"))
forplot$vaccine <- forplot$control == 0
forplot <- subset(forplot, !(ptid %in% c("infected", "non-infected", "placebo")))
forplot <- forplot[order(forplot$ptid, forplot$group, forplot$presponses), ]
ggplot(forplot) + geom_step(aes(x = presponses, y = postProb, group = ptid,
col = factor(hiv)),
alpha = 0.42) +
geom_step(data = summarized, aes(x = presponses, y = postProb,
linetype = ptid)) +
facet_grid(index ~ group) +
xlab("At Least % Responsive Subsets") +
ylab("Posterior Probabilities") +
scale_x_reverse()
integrateCDF <- function(x) {
x <- x[, 3:4]
result <- 0
for(i in 2:nrow(x)) {
base <- (x[i, 1] - x[i - 1, 1])
result <- result + base * (x[i, 2])
#result <- result + base * (x[i - 1, 2] - x[i, 2]) / 2
}
return(result)
}
intCDF <- summarize(group_by(forplot, ptid, group, index, hiv),
measure = integrateCDF(cbind(ptid, group, presponses, postProb)))
intCDF <- do.call("rbind", by(intCDF, list(intCDF$group, intCDF$index),
function(x) {
measure <- x$measure
x$measure <- (measure - mean(measure)) / sd(measure)
return(x)
}))
par(mfrow = c(2, 4), mar = rep(3, 4))
temp <- subset(intCDF, hiv != "placebo")
aucs <- by(temp, list(temp$group, temp$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$group), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
print(summary(glm(x$hiv == "infected" ~ x$measure, family = "binomial")))
return(auc)
})
n0 <- sum(infect$hiv == "infected")
n1 <- sum(infect$hiv == "non-infected")
pvals <- pwilcox(aucs * n0 * n1, n0, n1, lower.tail = FALSE)
ggplot(subset(intCDF, index != "!!"),
aes(x = hiv, y = measure, col = hiv)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(size = 0.1) +
facet_grid(index ~ group, scales= "free_y") +
theme_bw() + ylim(-2.5, 2.5)
intCDF
names(intCDF)
breadth <- intCDF
intCDF$gourp
intCDF$group
substr(intCDF$group, 5,6)
breadth$parent <- substr(breadth$group, 5,6)
breadth <- summarize(group_by(intCDF, ptid, index, hiv, parent),
measure = mean(measure))
breadth <- intCDF
breadth$parent <- substr(breadth$group, 5,6)
breadth <- summarize(group_by(breadth, ptid, index, hiv, parent),
measure = mean(measure))
aucs <- by(breadth, list(temp$parent, temp$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$group), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
print(summary(glm(x$hiv == "infected" ~ x$measure, family = "binomial")))
return(auc)
})
breadth
aucs <- by(breadth, list(breadth$parent, breadth$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$group), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
print(summary(glm(x$hiv == "infected" ~ x$measure, family = "binomial")))
return(auc)
})
main <- paste(unique(x$parent), unique(x$index), "AUC:", auc)
aucs <- by(breadth, list(breadth$parent, breadth$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$parent), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
return(auc)
})
par(mfrow = c(2, 2))
aucs <- by(breadth, list(breadth$parent, breadth$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$parent), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
return(auc)
})
temp <- subset(breadth, hiv != "placebo")
aucs <- by(temp, list(temp$parent, temp$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$parent), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
return(auc)
})
aucs <- by(temp, list(temp$parent, temp$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$parent), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
return(auc)
})
aucs
dim(tmep)
dim(temp)
dim(breadth)
infect$hiv <- "non-infected"
infect$hiv[infect$status == 1] <- "infected"
infect$hiv[outcome[, 2] == 1] <- "placebo"
assignments <- fit$assignmentList
names(assignments) <- substr(names(assignments), 1, 9)
assignments <- lapply(unique(names(assignments)), function(x) {
do.call("rbind", assignments[names(assignments) == x])
})
subsets <- names(fit$coefficients)
nfunctions <- sapply(subsets, function(x) length(strsplit(x, "+", fixed = TRUE)[[1]]) - 1)
weightList <- list()
weightList$poly <-  weights <- nfunctions / choose(5, nfunctions)
weightList$func <- rep(1, length(nfunctions))
resultList <- list()
for(w in 1:length(weightList)) {
weights <- weightList[[w]]
weightname <- names(weightList)[w]
resultList[[w]] <- list()
print(weightname)
for(i in 1:(length(assignments) + 3)) {
cat(i, " ")
if(i <= length(assignments)) {
samp <- assignments[[i]]
ptid <- fit$posteriors$ptid[i]
} else if(i == (length(assignments) + 1)) {
ptid <- "non-infected"
samp <- do.call("rbind", assignments[infect[, 3] == "non-infected"])
} else if(i == (length(assignments) + 2)){
ptid <- "placebo"
samp <- do.call("rbind", assignments[infect[, 3] == "placebo"])
} else {
ptid <- "infected"
samp <- do.call("rbind", assignments[infect[, 3] == "infected"])
}
#colnames(samp) <- substring(subsets, 1, 3) # for stim groups
#colnames(samp) <- substring(subsets, 1, 6) # for stim + 8 or 4 groups
colnames(samp) <- substring(subsets, 5, 6) # + 8 or 4 groups
#colnames(samp) <- substring(subsets, 5) # for cell-type groups
#colnames(samp) <- rep("all", ncol(samp)) # for just one plot
groups <- unique(colnames(samp))
subjDatList <- list()
for(j in 1:length(groups)) {
group <- groups[j]
subsamp <- samp[, colnames(samp) == group]
subw <- weights[colnames(samp) == group]
subw <- subw / sum(subw)
groupSize <- ncol(subsamp)
props <- numeric(groupSize + 1)
values <- subsamp %*% subw
uniqueValues <- c(0, sort(unique(values)), 1)
props <- sapply(uniqueValues, function(x) mean(values >= x))
subjDatList[[j]] <- data.frame(ptid = ptid, group = group,
index = weightname,
presponses = uniqueValues,
postProb = props)
}
resultList[[w]][[i]] <- do.call("rbind", subjDatList)
}
cat("\n")
}
responsedat <- do.call("rbind", do.call("rbind", resultList))
forplot <- merge(responsedat, infect, by.x = "ptid", by.y = "ptid",
all.x = TRUE)
summarized <- subset(forplot, ptid %in% c("infected", "non-infected", "placebo"))
forplot$vaccine <- forplot$control == 0
forplot <- subset(forplot, !(ptid %in% c("infected", "non-infected", "placebo")))
forplot <- forplot[order(forplot$ptid, forplot$group, forplot$presponses), ]
ggplot(forplot) + geom_step(aes(x = presponses, y = postProb, group = ptid,
col = factor(hiv)),
alpha = 0.42) +
geom_step(data = summarized, aes(x = presponses, y = postProb,
linetype = ptid)) +
facet_grid(index ~ group) +
xlab("At Least % Responsive Subsets") +
ylab("Posterior Probabilities") +
scale_x_reverse()
integrateCDF <- function(x) {
x <- x[, 3:4]
result <- 0
for(i in 2:nrow(x)) {
base <- (x[i, 1] - x[i - 1, 1])
result <- result + base * (x[i, 2])
#result <- result + base * (x[i - 1, 2] - x[i, 2]) / 2
}
return(result)
}
intCDF <- summarize(group_by(forplot, ptid, group, index, hiv),
measure = integrateCDF(cbind(ptid, group, presponses, postProb)))
intCDF <- do.call("rbind", by(intCDF, list(intCDF$group, intCDF$index),
function(x) {
measure <- x$measure
x$measure <- (measure - mean(measure)) / sd(measure)
return(x)
}))
par(mfrow = c(2, 4), mar = rep(3, 4))
temp <- subset(intCDF, hiv != "placebo")
aucs <- by(temp, list(temp$group, temp$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$group), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
print(summary(glm(x$hiv == "infected" ~ x$measure, family = "binomial")))
return(auc)
})
n0 <- sum(infect$hiv == "infected")
n1 <- sum(infect$hiv == "non-infected")
pvals <- pwilcox(aucs * n0 * n1, n0, n1, lower.tail = FALSE)
ggplot(subset(intCDF, index != "!!"),
aes(x = hiv, y = measure, col = hiv)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(size = 0.1) +
facet_grid(index ~ group, scales= "free_y") +
theme_bw() + ylim(-2.5, 2.5)
infect$hiv <- "non-infected"
infect$hiv[infect$status == 1] <- "infected"
infect$hiv[outcome[, 2] == 1] <- "placebo"
assignments <- fit$assignmentList
names(assignments) <- substr(names(assignments), 1, 9)
assignments <- lapply(unique(names(assignments)), function(x) {
do.call("rbind", assignments[names(assignments) == x])
})
subsets <- names(fit$coefficients)
nfunctions <- sapply(subsets, function(x) length(strsplit(x, "+", fixed = TRUE)[[1]]) - 1)
weightList <- list()
weightList$poly <-  weights <- nfunctions / choose(5, nfunctions)
weightList$func <- rep(1, length(nfunctions))
resultList <- list()
for(w in 1:length(weightList)) {
weights <- weightList[[w]]
weightname <- names(weightList)[w]
resultList[[w]] <- list()
print(weightname)
for(i in 1:(length(assignments) + 3)) {
cat(i, " ")
if(i <= length(assignments)) {
samp <- assignments[[i]]
ptid <- fit$posteriors$ptid[i]
} else if(i == (length(assignments) + 1)) {
ptid <- "non-infected"
samp <- do.call("rbind", assignments[infect[, 3] == "non-infected"])
} else if(i == (length(assignments) + 2)){
ptid <- "placebo"
samp <- do.call("rbind", assignments[infect[, 3] == "placebo"])
} else {
ptid <- "infected"
samp <- do.call("rbind", assignments[infect[, 3] == "infected"])
}
#colnames(samp) <- substring(subsets, 1, 3) # for stim groups
#colnames(samp) <- substring(subsets, 1, 6) # for stim + 8 or 4 groups
colnames(samp) <- substring(subsets, 5, 6) # + 8 or 4 groups
#colnames(samp) <- substring(subsets, 5) # for cell-type groups
#colnames(samp) <- rep("all", ncol(samp)) # for just one plot
groups <- unique(colnames(samp))
subjDatList <- list()
for(j in 1:length(groups)) {
group <- groups[j]
subsamp <- samp[, colnames(samp) == group]
subw <- weights[colnames(samp) == group]
subw <- subw / sum(subw)
groupSize <- ncol(subsamp)
props <- numeric(groupSize + 1)
values <- subsamp %*% subw
uniqueValues <- c(0, sort(unique(values)), 1)
props <- sapply(uniqueValues, function(x) mean(values >= x))
subjDatList[[j]] <- data.frame(ptid = ptid, group = group,
index = weightname,
presponses = uniqueValues,
postProb = props)
}
resultList[[w]][[i]] <- do.call("rbind", subjDatList)
}
cat("\n")
}
responsedat <- do.call("rbind", do.call("rbind", resultList))
forplot <- merge(responsedat, infect, by.x = "ptid", by.y = "ptid",
all.x = TRUE)
summarized <- subset(forplot, ptid %in% c("infected", "non-infected", "placebo"))
forplot$vaccine <- forplot$control == 0
forplot <- subset(forplot, !(ptid %in% c("infected", "non-infected", "placebo")))
forplot <- forplot[order(forplot$ptid, forplot$group, forplot$presponses), ]
ggplot(forplot) + geom_step(aes(x = presponses, y = postProb, group = ptid,
col = factor(hiv)),
alpha = 0.42) +
geom_step(data = summarized, aes(x = presponses, y = postProb,
linetype = ptid)) +
facet_grid(index ~ group) +
xlab("At Least % Responsive Subsets") +
ylab("Posterior Probabilities") +
scale_x_reverse()
integrateCDF <- function(x) {
x <- x[, 3:4]
result <- 0
for(i in 2:nrow(x)) {
base <- (x[i, 1] - x[i - 1, 1])
result <- result + base * (x[i, 2])
#result <- result + base * (x[i - 1, 2] - x[i, 2]) / 2
}
return(result)
}
intCDF <- summarize(group_by(forplot, ptid, group, index, hiv),
measure = integrateCDF(cbind(ptid, group, presponses, postProb)))
intCDF <- do.call("rbind", by(intCDF, list(intCDF$group, intCDF$index),
function(x) {
measure <- x$measure
x$measure <- (measure - mean(measure)) / sd(measure)
return(x)
}))
par(mfrow = c(2, 2), mar = rep(3, 4))
temp <- subset(intCDF, hiv != "placebo")
aucs <- by(temp, list(temp$group, temp$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$group), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
print(summary(glm(x$hiv == "infected" ~ x$measure, family = "binomial")))
return(auc)
})
n0 <- sum(infect$hiv == "infected")
n1 <- sum(infect$hiv == "non-infected")
pvals <- pwilcox(aucs * n0 * n1, n0, n1, lower.tail = FALSE)
ggplot(subset(intCDF, index != "!!"),
aes(x = hiv, y = measure, col = hiv)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(size = 0.1) +
facet_grid(index ~ group, scales= "free_y") +
theme_bw() + ylim(-2.5, 2.5)
infect$hiv <- "non-infected"
infect$hiv[infect$status == 1] <- "infected"
infect$hiv[outcome[, 2] == 1] <- "placebo"
assignments <- fit$assignmentList
names(assignments) <- substr(names(assignments), 1, 9)
assignments <- lapply(unique(names(assignments)), function(x) {
do.call("rbind", assignments[names(assignments) == x])
})
subsets <- names(fit$coefficients)
nfunctions <- sapply(subsets, function(x) length(strsplit(x, "+", fixed = TRUE)[[1]]) - 1)
weightList <- list()
weightList$poly <-  weights <- nfunctions / choose(5, nfunctions)
weightList$func <- rep(1, length(nfunctions))
resultList <- list()
for(w in 1:length(weightList)) {
weights <- weightList[[w]]
weightname <- names(weightList)[w]
resultList[[w]] <- list()
print(weightname)
for(i in 1:(length(assignments) + 3)) {
cat(i, " ")
if(i <= length(assignments)) {
samp <- assignments[[i]]
ptid <- fit$posteriors$ptid[i]
} else if(i == (length(assignments) + 1)) {
ptid <- "non-infected"
samp <- do.call("rbind", assignments[infect[, 3] == "non-infected"])
} else if(i == (length(assignments) + 2)){
ptid <- "placebo"
samp <- do.call("rbind", assignments[infect[, 3] == "placebo"])
} else {
ptid <- "infected"
samp <- do.call("rbind", assignments[infect[, 3] == "infected"])
}
#colnames(samp) <- substring(subsets, 1, 3) # for stim groups
colnames(samp) <- substring(subsets, 1, 6) # for stim + 8 or 4 groups
#colnames(samp) <- substring(subsets, 5, 6) # + 8 or 4 groups
#colnames(samp) <- substring(subsets, 5) # for cell-type groups
#colnames(samp) <- rep("all", ncol(samp)) # for just one plot
groups <- unique(colnames(samp))
subjDatList <- list()
for(j in 1:length(groups)) {
group <- groups[j]
subsamp <- samp[, colnames(samp) == group]
subw <- weights[colnames(samp) == group]
subw <- subw / sum(subw)
groupSize <- ncol(subsamp)
props <- numeric(groupSize + 1)
values <- subsamp %*% subw
uniqueValues <- c(0, sort(unique(values)), 1)
props <- sapply(uniqueValues, function(x) mean(values >= x))
subjDatList[[j]] <- data.frame(ptid = ptid, group = group,
index = weightname,
presponses = uniqueValues,
postProb = props)
}
resultList[[w]][[i]] <- do.call("rbind", subjDatList)
}
cat("\n")
}
responsedat <- do.call("rbind", do.call("rbind", resultList))
forplot <- merge(responsedat, infect, by.x = "ptid", by.y = "ptid",
all.x = TRUE)
summarized <- subset(forplot, ptid %in% c("infected", "non-infected", "placebo"))
forplot$vaccine <- forplot$control == 0
forplot <- subset(forplot, !(ptid %in% c("infected", "non-infected", "placebo")))
forplot <- forplot[order(forplot$ptid, forplot$group, forplot$presponses), ]
ggplot(forplot) + geom_step(aes(x = presponses, y = postProb, group = ptid,
col = factor(hiv)),
alpha = 0.42) +
geom_step(data = summarized, aes(x = presponses, y = postProb,
linetype = ptid)) +
facet_grid(index ~ group) +
xlab("At Least % Responsive Subsets") +
ylab("Posterior Probabilities") +
scale_x_reverse()
integrateCDF <- function(x) {
x <- x[, 3:4]
result <- 0
for(i in 2:nrow(x)) {
base <- (x[i, 1] - x[i - 1, 1])
result <- result + base * (x[i, 2])
#result <- result + base * (x[i - 1, 2] - x[i, 2]) / 2
}
return(result)
}
intCDF <- summarize(group_by(forplot, ptid, group, index, hiv),
measure = integrateCDF(cbind(ptid, group, presponses, postProb)))
intCDF <- do.call("rbind", by(intCDF, list(intCDF$group, intCDF$index),
function(x) {
measure <- x$measure
x$measure <- (measure - mean(measure)) / sd(measure)
return(x)
}))
par(mfrow = c(2, 2), mar = rep(3, 4))
temp <- subset(intCDF, hiv != "placebo")
aucs <- by(temp, list(temp$group, temp$index), function(x) {
rocfit <- roc(x$hiv ~ x$measure)
auc <- round(rocfit$auc, 3)
main <- paste(unique(x$group), unique(x$index), "AUC:", auc)
plot(rocfit, main = main)
print(summary(glm(x$hiv == "infected" ~ x$measure, family = "binomial")))
return(auc)
})
n0 <- sum(infect$hiv == "infected")
n1 <- sum(infect$hiv == "non-infected")
pvals <- pwilcox(aucs * n0 * n1, n0, n1, lower.tail = FALSE)
ggplot(subset(intCDF, index != "!!"),
aes(x = hiv, y = measure, col = hiv)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(size = 0.1) +
facet_grid(index ~ group, scales= "free_y") +
theme_bw() + ylim(-2.5, 2.5)
infectresult
infectresult
infectresult[order(infectresult$aucs, decreasing = TRUE), ]
